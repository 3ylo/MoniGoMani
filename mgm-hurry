#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -* vim: syntax=python -*-
# pylint: disable=W0108

#                                       _
#                                      | |
#  _ __ ___    __ _  _ __ ___   ______ | |__   _   _  _ __  _ __  _   _
# | '_ ` _ \  / _` || '_ ` _ \ |______|| '_ \ | | | || '__|| '__|| | | |
# | | | | | || (_| || | | | | |        | | | || |_| || |   | |   | |_| |
# |_| |_| |_| \__, ||_| |_| |_|        |_| |_| \__,_||_|   |_|    \__, |
#              __/ |                                               __/ |
#             |___/                                               |___/
#
# --- ↑↓ Do not remove these libs ↑↓ -----------------------------------------------------------------------------------

"""mgm-hurry is a CLI Tool for setting up and managing Freqtrade in combination with MoniGoMani"""

import glob
import json
import logging
import os
import sys
from datetime import datetime, timedelta
from math import ceil
from string import Template

import fire
from art import tprint
from InquirerPy import prompt
from InquirerPy.validator import NumberValidator

from user_data.mgm_tools.mgm_hurry.FreqtradeCli import FreqtradeCli
from user_data.mgm_tools.mgm_hurry.MoniGoManiCli import MoniGoManiCli
from user_data.mgm_tools.mgm_hurry.MoniGoManiConfig import MoniGoManiConfig
from user_data.mgm_tools.mgm_hurry.MoniGoManiLogger import MoniGoManiLogger

# ---- ↑ Do not remove these libs ↑ ------------------------------------------------------------------------------------


class MGMHurry:
    """
    💨 Your command is my objective 💨

    CLI Tool for setting up and managing a Freqtrade instance containing the MoniGoMani Framework & Strategy

    Attributes:
        monigomani_config   The monigomani_config object
        freqtrade_cli       The FreqtradeCli object
        _logger             The logging function out of MoniGoManiLogger
    """
    monigomani_config: MoniGoManiConfig
    freqtrade_cli: FreqtradeCli
    _logger: logging

    def __init__(self):
        tprint('mgm-hurry')

        self._basedir = os.getcwd()
        self._logger = MoniGoManiLogger(self._basedir).get_logger()
        self.monigomani_config = MoniGoManiConfig(self._basedir)

        if self.monigomani_config.reload() is False:
            self._logger.error('⚠️ Failed to load or create ".hurry" config file.')

        self.freqtrade_cli = FreqtradeCli(self._basedir)
        self.monigomani_cli = MoniGoManiCli(self._basedir)

    def up(self):  # pylint: disable=invalid-name
        """
        The all in one command. Hurry up, turn it up!
        """

        questions = [
            {
                'type': 'confirm',
                'name': 'install_freqtrade',
                'message': '💨 Do you want to install Freqtrade?'
            },
            {
                'type': 'confirm',
                'name': 'install_mgm',
                'message': '💨 Do you want to install MoniGoMani?'
            },
            {
                'type': 'confirm',
                'name': 'run_setup',
                'message': '💨 Do you want to configure it now?'
            },
            {
                'type': 'confirm',
                'name': 'download_static_pairlist',
                'message': '💨 Do you want to generate a static pairlist now?'
            },
            {
                'type': 'confirm',
                'name': 'download_data',
                'message': '💨 Do you want to download candle data now?'
            },
            {
                'type': 'confirm',
                'name': 'do_hyperopt',
                'message': '💨 Do you want to hyperopt now?'
            },
            {
                'type': 'confirm',
                'name': 'do_backtest',
                'message': '💨 Do you want to backtest now?'
            },
            {
                'type': 'list',
                'name': 'start_trading',
                'message': '💨 Do you want to start trading?',
                'choices': [
                    {'name': 'No', 'value': 0},
                    {'name': 'Yes, Dry-Run please', 'value': 1},
                    {'name': 'Yes, for real!', 'value': 2}
                ]
            }
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        if answers.get('install_freqtrade') is True:
            self.install_freqtrade()

        if answers.get('install_mgm') is True:
            self.install_mgm()

        if answers.get('run_setup') is True:
            self.setup()

        if answers.get('download_static_pairlist') is True:
            self.download_static_pairlist()

        if answers.get('download_data') is True:
            self.download_candle_data()

        if answers.get('do_hyperopt') is True:
            ho_results_found = False
            strategy = self.monigomani_config.config['hyperopt']['strategy']
            if strategy == 'MoniGoManiHyperStrategy':
                mgm_config_ho = self.monigomani_config.config['mgm_config_names']['mgm-config-hyperopt']
                if os.path.isfile(f'{self._basedir}/user_data/{mgm_config_ho}'):
                    ho_results_found = True
            elif os.path.isfile(f'{self._basedir}/user_data/strategies/{strategy}.json'):
                ho_results_found = True

            if ho_results_found is True:
                clean_start = prompt(questions=[{
                    'type': 'list',
                    'name': 'clean_start',
                    'message': 'Previous HyperOpt Results where found. Do you wish to remove these for a clean start?',
                    'choices': [
                        {'name': 'Yes', 'value': 1},
                        {'name': 'No', 'value': 0}
                    ]}
                ])

                if clean_start.get('clean_start') == 1:
                    self.cleanup(strategy)

            # First HO run
            self.hyperopt(do_backtest=answers.get('do_backtest'))
            ho_choice = prompt(questions=[{
                'type': 'input',
                'name': 'ho_epoch',
                'message': '(HO 1) Choose the epoch which fits the best to your liking: (0-1000) ',
                'filter': lambda val: int(val),
                'validate': NumberValidator()
            }])
            self.hyperopt_show_epoch(ho_choice.get('ho_epoch'))

            # Second HO run
            self.hyperopt(do_backtest=answers.get('do_backtest'))
            ho_choice = prompt(questions=[{
                'type': 'input',
                'name': 'ho_epoch',
                'message': '(HO 2) Choose the epoch which fits the best to your liking: (0-1000) ',
                'filter': lambda val: int(val),
                'validate': NumberValidator()
            }])
            self.hyperopt_show_epoch(ho_choice.get('ho_epoch'))

        if answers.get('do_backtest') is True:
            self.backtest()

        if answers.get('start_trading') > 0:
            if answers.get('start_trading') == 2:
                self.start_trader(False)
            else:
                self.start_trader(True)
        else:
            self._logger.info('💨 Executing mgm-hurry up finished.')

    def install_freqtrade(self, target_dir: str = None, branch: str = 'develop',
                          commit: str = '3503fdb4ec31be99f433fdce039543e0911964d6'):
        """
        Install Freqtrade the easy way.

        :param target_dir: (string, optional) Specify a target_dir to install Freqtrade. Defaults to os.getcwd().
        :param branch: (string, optional) Checkout a specific branch. Defaults to 'develop'.
        :param commit: (str) Checkout a specific commit. Defaults to latest supported by MoniGoMani.
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Install Freqtrade')
        self._logger.info('💨 💨 💨')

        # Checking Freqtrade installation to confirm for overwrite
        if self.freqtrade_cli.installation_exists() is True:
            questions = [
                {
                    'type': 'confirm',
                    'message': 'It looks like Freqtrade is already installed. Proceed to overwrite?',
                    'name': 'proceed',
                    'default': False
                },
            ]

            result = prompt(questions)

            if result.get('proceed') is False:
                self._logger.info('Skipping overwriting Freqtrade installation.')
                return False

        if target_dir is None:
            target_dir = self._basedir

        self.freqtrade_cli.download_setup_freqtrade(target_dir, branch, commit)

        self._logger.info('🍺 Freqtrade has been installed. '
                          'You can now proceed to install MoniGoMani. (Hint: mgm-hurry install_mgm)')

        return True

    def install_mgm(self, target_dir: str = None, branch: str = 'development', commit: str = None):
        """
        Install the MoniGoMani Framework & Strategy.

        :param branch: (string, optional) Checkout a specific branch. Defaults to 'development'.
        :param target_dir: (string, optional) Specify a target_dir to install MoniGoMani. Defaults to os.getcwd().
        :param commit: (str) Checkout a specific commit. Defaults to None aka latest.
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Install MoniGoMani')
        self._logger.info('💨 💨 💨')

        # Checking MoniGoMani installation to confirm for overwrite
        if self.monigomani_cli.installation_exists() is True:
            questions = [
                {
                    'type': 'confirm',
                    'message': 'It looks like MoniGoMani is already installed. Proceed to overwrite?',
                    'name': 'proceed',
                    'default': False
                }
            ]

            result = prompt(questions)

            if result.get('proceed') is False:
                self._logger.info('Skipping overwriting MoniGoMani installation.')
                return False

            # Check if the private config file already exists.
            cfg_filename = self.monigomani_config.get_config_filename('mgm-config-private')
            mgm_private_json_name = self.monigomani_config.config['mgm_config_names']['mgm-config-private']

            questions = [
                {
                    'type': 'confirm',
                    'message': f'Should I print your "{mgm_private_json_name}" contents '
                               f'so you can copy it over to new installation?',
                    'name': 'print',
                    'default': False,
                    'when': lambda result: os.path.isfile(cfg_filename)
                },
                {
                    'type': 'confirm',
                    'message': 'WARNING: You are printing sensitive information '
                               'which you should NEVER SHARE with anybody. Really proceed?',
                    'name': 'print_confirmed',
                    'default': False,
                    'when': lambda result: result['print']
                }
            ]

            result = prompt(questions)

            if result.get('print_confirmed') is True:
                # Read 'mgm-config-private' and pretty print it
                with open(f'{self._basedir}/user_data/{mgm_private_json_name}', ) as mgm_private_config:
                    print(json.dumps(json.load(mgm_private_config), indent=4))

        if target_dir is None:
            target_dir = self._basedir

        self.monigomani_cli.download_setup_mgm(target_dir, branch, commit)
        self.monigomani_config.create_config_files(self._basedir)
        self._logger.info('🍺 MoniGoMani has been installed. You can now proceed to setup your instance. '
                          '(Hint: mgm-hurry setup)')

    def setup(self):
        """
        Saves setup data based on your answers
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Setup')
        self._logger.info('💨 💨 💨')

        self._logger.info('🤓 Let\'s answer some questions to make your life easier.')

        strategies = map(lambda f: os.path.basename(f).replace('.py', ''),
                         glob.glob(f'{self._basedir}/user_data/strategies/*.py'))

        strategies_choices = []
        for strat in strategies:
            if strat != 'MasterMoniGoManiHyperStrategy':
                strategies_choices.append({'name': strat, 'value': strat})

        if len(strategies_choices) == 0:
            strat_dir = f'{self._basedir}/user_data/strategies/'
            self._logger.error(f'🤷 I could not find any strategy in {strat_dir}. '
                               f'Did you install Freqtrade & MoniGoMani?')
            sys.exit(1)

        self.monigomani_config.create_config_files(self._basedir)

        hyperopts = map(lambda f: os.path.basename(f).replace('.py', ''),
                        glob.glob(f'{self._basedir}/user_data/hyperopts/*.py'))

        hyperopts_choices = []
        for hyperopt in hyperopts:
            hyperopts_choices.append({'name': hyperopt, 'value': hyperopt})

        if len(hyperopts_choices) == 0:
            ho_dir = f'{self._basedir}/user_data/hyperopts/'
            self._logger.error(f'🤷 I could not find any hyperopts in {ho_dir}. '
                               f'Did you install Freqtrade & MoniGoMani?')
            sys.exit(1)

        self.monigomani_config.reload()

        questions = [{
            'type': 'list',
            'name': 'install_type',
            'message': 'Which way you want to use Freqtrade?',
            'choices': ['docker', 'source'],
            'default': self.monigomani_config.get('install_type') or 'source'
        }, {
            'type': 'input',
            'name': 'timerange',
            'message': 'Please enter the default timerange you want to use:',
            'default': self.monigomani_config.get('timerange') or '20210501-20210616'
        }, {
            'type': 'list',
            'name': 'ho_strategy',
            'message': 'Which HyperOpt Strategy do you want to use?',
            'choices': strategies_choices,
            'default': self.monigomani_config.get('hyperopt')['strategy'] or 'MoniGoManiHyperStrategy'
        }, {
            'type': 'list',
            'name': 'ho_loss',
            'message': 'Which HyperOpt Loss do you want to use?',
            'choices': hyperopts_choices,
            'default': self.monigomani_config.get('hyperopt')['loss'] or 'WinRatioAndProfitRatioLoss'
        }, {
            'type': 'checkbox',
            'name': 'ho_spaces',
            'message': 'Which spaces do you want to HyperOpt?',
            'choices': map(
                lambda x: {'enabled': True, 'name': x['name'], 'value': x['value']}
                if x['value'] in self.monigomani_config.get('hyperopt')['spaces'].split(' ')
                else {'enabled': False, 'name': x['name'], 'value': x['value']},
                [
                    {'enabled': False, 'name': 'default', 'value': 'default'},
                    {'enabled': False, 'name': 'buy', 'value': 'buy'},
                    {'enabled': False, 'name': 'sell', 'value': 'sell'},
                    {'enabled': False, 'name': 'roi', 'value': 'roi'},
                    {'enabled': False, 'name': 'stoploss', 'value': 'stoploss'},
                    {'enabled': False, 'name': 'trailing', 'value': 'trailing'},
                    {'enabled': False, 'name': 'all', 'value': 'all'}
                ]
            ),
            'filter': lambda val: ' '.join(val)
        }, {
            'type': 'input',
            'name': 'ho_quotation',
            'message': 'Please enter the default stake currency (aka quote) you want to use:',
            'default': self.monigomani_config.get('hyperopt')['quote'] or 'USDT'
        }, {
            'type': 'input',
            'name': 'ho_epochs',
            'message': 'Please enter the amount of epochs you want to HyperOpt:',
            'default': str(self.monigomani_config.get('hyperopt')['epochs']) or '1000',
            'filter': lambda val: int(val)
        }, {
            'type': 'confirm',
            'message': 'Do you want to also setup your exchange?',
            'name': 'proceed_exchange',
            'default': True,
        }, {
            'type': 'list',
            'name': 'exchange',
            'message': 'Which exchange do you want to use?',
            'choices': ['binance', 'ftx', 'bittrex'],
            'when': lambda result: result['proceed_exchange']
        }, {
            'type': 'password',
            'name': 'api_key',
            'message': 'Please enter the exchange API key: ',
            'when': lambda result: result['proceed_exchange']
        }, {
            'type': 'password',
            'name': 'api_secret',
            'message': 'Please enter the exchange API secret: ',
            'when': lambda result: result['proceed_exchange']
        }, {
            'type': 'input',
            'name': 'username',
            'message': 'Please enter the Username you want to use:',
            'default': self.monigomani_config.get('username') or 'MoniGoMani Community'
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit(1)

        if answers.get('install_type') == 'source':
            ft_binary = f'source {self._basedir}/.env/bin/activate; freqtrade'
        else:
            ft_binary = 'docker-compose run --rm freqtrade'

        new_config = {
            'config': {
                'username': answers.get('username'),
                'install_type': answers.get('install_type'),
                'ft_binary': ft_binary,
                'timerange': answers.get('timerange'),
                'exchange': answers.get('exchange') or 'none',
                'hyperopt': {
                    'strategy': answers.get('ho_strategy'),
                    'loss': answers.get('ho_loss'),
                    'spaces': answers.get('ho_spaces') or 'default',
                    'quote': answers.get('ho_quotation'),
                    'epochs': answers.get('ho_epochs')
                },
                'mgm_config_names': {
                    'mgm-config': 'mgm-config.json',
                    'mgm-config-private': 'mgm-config-private.json',
                    'mgm-config-hyperopt': 'mgm-config-hyperopt.json'
                }
            }
        }

        self.monigomani_config.write_hurry_dotfile(new_config)
        # Overwrite the new stake currency in '.hurry' & mgm-config[stake_currency]
        self.monigomani_config.save_stake_currency(answers.get('ho_quotation'))

        if answers.get('proceed_exchange') is True:
            cred = {
                'exchange': answers.get('exchange'),
                'api_key': answers.get('api_key'),
                'api_secret': answers.get('api_secret')
            }

            self.monigomani_config.save_exchange_credentials(cred)

        self.__setup_telegram()

    def cleanup(self, strategy: str = 'MoniGoManiHyperStrategy'):
        """
        Deletes stored HyperOpt config(s) from previous run(s)

        :param strategy: (Optional, string) Name of the Strategy to cleanup, defaults to 'MoniGoManiHyperStrategy'
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Cleanup')
        self._logger.info('💨 💨 💨')

        # Remove hyperopt files to cleanup
        cleaned_up = self.monigomani_config.cleanup_hyperopt_files(strategy)

        self._logger.info(f'🍺 Cleanup successful, {strategy} ready for a fresh HyperOpt Run...') if cleaned_up is True \
            else self._logger.info(f'🍺 No Cleanup was needed, {strategy} ready for a fresh HyperOpt Run...')

    def download_candle_data(self, timerange: str = None):
        """
        Downloads candle data for the given timerange.

        :param timerange: (string, optional) Timerange from/to in string format (start-end): yyyymmdd-yyyymmdd.
            Defaults to timerange out of ".hurry" config file. -or- for preset timerange: down, side, up
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Download candle data')
        self._logger.info('💨 💨 💨')

        if self.monigomani_config.reload() is False:
            self._logger.error('🤷 No Hurry config file found. Please run: mgm-hurry setup')
            sys.exit(1)

        timerange = self.monigomani_config.get_preset_timerange(timerange)

        if self.freqtrade_cli.installation_exists() is False:
            self._logger.error('🤷 No Freqtrade installation found. I crash.')

        questions = [{
            'type': 'input',
            'name': 'timerange',
            'message': 'Please enter the timerange you want to use: ',
            'default': timerange
        }, {
            'type': 'checkbox',
            'name': 'tickers',
            'message': 'Specify which tickers to download: ',
            'choices': [
                {'name': '1m', 'value': '1m', 'enabled': False},
                {'name': '3m', 'value': '3m', 'enabled': False},
                {'name': '5m', 'value': '5m', 'enabled': True},
                {'name': '15m', 'value': '15m', 'enabled': False},
                {'name': '30m', 'value': '30m', 'enabled': True},
                {'name': '1h', 'value': '1h', 'enabled': False},
                {'name': '2h', 'value': '2h', 'enabled': False},
                {'name': '4h', 'value': '4h', 'enabled': False},
                {'name': '6h', 'value': '6h', 'enabled': False},
                {'name': '8h', 'value': '8h', 'enabled': False},
                {'name': '12h', 'value': '12h', 'enabled': False},
                {'name': '1d', 'value': '1d', 'enabled': False},
                {'name': '3d', 'value': '3d', 'enabled': False},
                {'name': '1w', 'value': '1w', 'enabled': False},
                {'name': '2w', 'value': '2w', 'enabled': False},
                {'name': '1M', 'value': '1M', 'enabled': False},
                {'name': '1y', 'value': '1y', 'enabled': False}
            ],
            'validate': lambda result: len(result) >= 1,
            'invalid_message': 'should be at least 1 selection',
            'instruction': '(select at least 1)',
            'filter': lambda val: ' '.join(val)
        }, {
            'type': 'list',
            'name': 'extra_data',
            'message': 'Download extra data for "mgm-config"\'s defined "startup_candle_count" & "timerange"?',
            'choices': [
                {'name': 'Yes', 'value': 1},
                {'name': 'No', 'value': 0}
            ]
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        timerange = answers.get('timerange')
        tickers = answers.get('tickers')
        extra_data = answers.get('extra_data')

        if extra_data == 1:
            mgm_config_files = self.monigomani_config.load_config_files()
            timeframe_minutes = self.monigomani_cli.timeframe_to_minutes(
                mgm_config_files['mgm-config']['monigomani_settings']['timeframe'])
            startup_candle_count = mgm_config_files['mgm-config']['monigomani_settings']['startup_candle_count']

            extra_days = ceil((timeframe_minutes * startup_candle_count) / (60 * 24))
            split_timerange = timerange.split('-')
            new_start_date = datetime.strptime(split_timerange[0], '%Y%m%d') - timedelta(extra_days)
            timerange = f'{new_start_date.strftime("%Y%m%d")}-{split_timerange[1]}'
            self._logger.info(f'👉 Added {extra_days} extra days to the timerange for the "startup_candle_count"')

        self._logger.info(f'👉 Downloading candle data ({tickers}) for timerange {timerange}')

        dcd = f'{self.monigomani_config.config["ft_binary"]} download-data --timerange {timerange} \
              -t {tickers} {self.monigomani_config.command_configs()}'

        self._logger.debug(dcd)
        self.monigomani_cli.run_command(dcd)
        self._logger.info('🍺 Downloading candle data finished.')

    def download_static_pairlist(self):
        """
        Downloads StaticPairList and saves into mgm_pair_lists folder.

        :return None
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Download Top Volume Static Pairlist')
        self._logger.info('💨 💨 💨')

        if self.monigomani_config.reload() is False:
            self._logger.error('🤷 No Hurry config file found. Please run: mgm-hurry setup')
            sys.exit(1)

        if self.freqtrade_cli.installation_exists() is False:
            self._logger.error('🤷 Whaaaa.. No Freqtrade installation found. Beats me...')
            sys.exit(1)

        # Download and generate a static pairlist
        self._logger.info('🤖 Generating new static pairlist...')
        quote = self.monigomani_config.config['hyperopt']['quote']
        exchange = self.monigomani_config.config['exchange'].title()
        static_pairlist = self.freqtrade_cli.download_static_pairlist(quote, exchange)

        # Save new static pairlist to his own pairlist json file
        self._logger.info('🤖 Saving fresh static pairlist into mgm_pair_lists/...')
        with open(f'{self._basedir}/user_data/mgm_pair_lists/{exchange}-{quote}-Top-Volume-StaticPairList.json', 'w+') \
                as pairlist_file:
            data_format = {'exchange': {'pair_whitelist': static_pairlist}}
            json.dump(data_format, pairlist_file, indent=4)

        mgm_json_name = self.monigomani_config.config['mgm_config_names']['mgm-config']
        self._logger.info(f'🍺 Saving pairlist as whitelist to "{mgm_json_name}"...')
        # Overwrite the new static pairlist to the exchange config in mgm-config[exchange][pair_whitelist]
        mgm_config_file = self.monigomani_config.get_config_filename('mgm-config')
        with open(mgm_config_file, ) as mgm_config:
            try:
                mgm_config_object = json.load(mgm_config)
            except Exception:
                mgm_config_object = {'exchange': {'pair_whitelist': []}}
            mgm_config.close()

        with open(mgm_config_file, 'w') as mgm_config:
            mgm_config_object['exchange']['pair_whitelist'] = static_pairlist
            json.dump(mgm_config_object, mgm_config, indent=4)
            mgm_config.close()

    def hyperopt(self, timerange: str = None, strategy: str = None, loss: str = None, spaces: str = None,
                 enable_protections: bool = True, random_state: int = None, apply_best_results: bool = True,
                 clean_start: bool = False, do_backtest: bool = True, output_file_name: str = None, jobs: int = None,
                 min_trades: int = None):
        """
        HyperOpt Magic. Runs HyperOpt process to find out the most positive settings, automatically saves results.

        :param timerange: (str, Optional): timerange from/to in format (start-end): yyyymmdd-yyyymmdd
            or preset [up, down, side]. Defaults to value in '.hurry'
        :param strategy: (str, Optional): Hyper Opt strategy to use. Defaults to value in '.hurry'
        :param loss: (str, Optional): Specify the HyperOptLoss which you want to use. Defaults to value in '.hurry'
        :param spaces: (str, Optional): Spaces (space delimited) to optimize
            for [default, all, buy, sell, roi, stoploss, etc]. Defaults to value in '.hurry'
        :param enable_protections: (bool, Optional): Add '--enable-protections' flag to HO-command. Defaults to True.
        :param random_state: (int, Optional): Add '--random-state random_state' flag to HO-command. Defaults to None.
        :param apply_best_results: (bool, Optional): Apply 'best' HO results direct after HO? Defaults to True.
        :param clean_start: (bool, Optional): Cleanup MoniGoMani before starting the HO? Defaults to False.
        :param do_backtest: (bool, Optional): Do a BackTest after the HO? Defaults to True.
        :param output_file_name: (str, Optional) Name of the '.log' file(s).
            Defaults to 'HyperOpt/BackTestResults-<Current-DateTime>'
        :param jobs: (int) Amount of parallel workers (CPU cores) to use, gets set automatically by default
        :param min_trades: (int) Minimal amount of trades wished to be reached. Unused by default
        """

        if strategy is None:
            strategy = self.monigomani_config.config['hyperopt']['strategy']

        if clean_start is True:
            self.cleanup(strategy)

        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Starting HyperOpt run. Keep calm while your computer burns 🔥')
        self._logger.info('💨 💨 💨')

        timerange = self.monigomani_config.get_preset_timerange(timerange)

        if loss is None:
            loss = self.monigomani_config.config['hyperopt']['loss']

        if spaces is None:
            spaces = self.monigomani_config.config['hyperopt']['spaces']

        cmd = f'$ft_binary hyperopt -s $ho_strategy {self.monigomani_config.command_configs()}' \
              f'--hyperopt-loss $ho_loss --spaces $ho_spaces -e $ho_epochs --timerange $timerange '

        if enable_protections is True:
            cmd = f'{cmd.strip()} --enable-protections '
        if random_state is not None:
            cmd = f'{cmd.strip()} --random-state $random_state '
        if jobs is not None:
            cmd = f'{cmd.strip()} -j $jobs '
        if min_trades is not None:
            cmd = f'{cmd.strip()} --min-trades $min_trades '

        cmd = Template(cmd).substitute(
            ft_binary=self.monigomani_config.config['ft_binary'],
            ho_strategy=strategy,
            ho_loss=loss,
            ho_spaces=spaces,
            ho_epochs=self.monigomani_config.config['hyperopt']['epochs'],
            timerange=timerange,
            random_state=random_state,
            jobs=jobs,
            min_trades=min_trades)

        self._logger.debug(cmd)

        backtest_file_name = output_file_name
        hyperopt_file_name = output_file_name
        if output_file_name is None:
            datetime_now = datetime.now().strftime('%d-%m-%Y-%H-%M-%S')
            backtest_file_name = f'BackTestResults-{datetime_now}'
            hyperopt_file_name = f'HyperOptResults-{datetime_now}'

        output_file_path = f'{self._basedir}/user_data/hyperopt_results/{hyperopt_file_name}.log'
        self.monigomani_cli.run_command(cmd, output_file_path)
        MoniGoManiLogger(self._basedir).post_message(username=self.monigomani_config.config['username'],
                                                     message=f'🚀 Fresh **{strategy}** HyperOpt Results ⬇️',
                                                     results_path=output_file_path)

        # ToDo: Auto Create & Post a TotalOverallSignalImportanceCalculator Report
        if (apply_best_results is True) and (strategy == 'MoniGoManiHyperStrategy'):
            self.monigomani_cli.apply_mgm_results(strategy)
        elif do_backtest is True:
            self._logger.warning('🤷 Backtesting without HyperOptResults applied?..')
        if apply_best_results is False:
            self.cleanup(strategy)

        if do_backtest is True:
            self.backtest(timerange=timerange, strategy=strategy,
                          enable_protections=enable_protections, output_file_name=backtest_file_name)
        else:
            MoniGoManiLogger(self._basedir).post_setup(config=self.monigomani_config.config, strategy=strategy,
                                                       basedir=self._basedir)

        self._logger.info('🍺 HyperOpt run ready... 🥵')

    def hyperopt_show_results(self, only_best: bool = True, only_profitable: bool = False):
        """
        Show hyperopt results after choosing a .fthypt file.

        :param only_best: (bool, Optional); Show only best epochs. Defaults to True.
        :param only_profitable: (bool, Optional); Show only profitable epochs. Defaults to False.
        """

        choice = self.freqtrade_cli.choose_fthypt_file()

        self._logger.info(f'👉 Showing hyperopt results for: {choice}')

        best = '--best' if only_best is True else ''
        profit = '--profitable' if only_profitable is True else ''

        dcd = f'{self.monigomani_config.config["ft_binary"]} hyperopt-list ' \
              f'--hyperopt-filename "{choice}" {best} {profit}'
        self._logger.debug(dcd)

        self.monigomani_cli.run_command(dcd)

    def hyperopt_show_epoch(self, epoch: int = 0, strategy: str = None,
                            apply: bool = True, fthypt: bool = None):
        """
        Shows the HyperOpt results for a given epoch.

        :param epoch: (int) The epoch number to show the results from
        :param strategy: (str) The strategy used. Defaults to value in '.hurry'
        :param apply: (bool) Apply the results of the epoch. Defaults to true
        :param fthypt: (bool) If 'true' an interactive prompt will launch to pick an '.fthypt' file of choice.
            Defaults to latest'
        """
        self._logger.info('💨 💨 💨')
        self._logger.info(f'👉 Hyperopt show {"" if apply is False else "and apply "}results')
        self._logger.info('💨 💨 💨')

        if fthypt is True:
            fthypt_name = self.freqtrade_cli.choose_fthypt_file()

        if epoch == 0:
            self._logger.error('🤷 Please pass the epoch number through. '
                               'Hint: mgm-hurry hyperopt_show_epoch --epoch=837')
            sys.exit(1)

        self._logger.info(f'👉 Showing {"" if apply is False else "and applying "}HyperOpt results for epoch #{epoch}')

        command = f'{self.monigomani_config.config["ft_binary"]} hyperopt-show -n {epoch} ' \
                  f'{self.monigomani_config.command_configs()}'

        if fthypt is True:
            command += f' --hyperopt-filename {fthypt_name}'

        self.monigomani_cli.run_command(command)

        if strategy is None:
            strategy = self.monigomani_config.config['hyperopt']['strategy']
        if (apply is True) and (strategy == 'MoniGoManiHyperStrategy'):
            self.monigomani_cli.apply_mgm_results(strategy)

        if apply is True:
            self._logger.info(f'🍺 Hyperopt results of epoch #{epoch} are applied.')
        else:
            self.cleanup(strategy)

    def backtest(self, timerange: str = None, strategy: str = None,
                 enable_protections: bool = True, output_file_name: str = None):
        """
        Run a backtest session and automatically save the results.

        :param timerange: (string, Optional): The target timerange for backtesting. Defaults to timerange in '.hurry'.
        :param strategy: (str, Optional): Strategy to use during BackTesting. Defaults to value in '.hurry'
        :param enable_protections: (bool, Optional): Whether or not to enable protections. Defaults to True.
        :param output_file_name: (str, Optional) Name of the '.log' file(s).
            Defaults to 'BackTestResults-<Current-DateTime>'
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Start BackTesting. Lets see how it all turns out!')
        self._logger.info('💨 💨 💨')

        timerange = self.monigomani_config.get_preset_timerange(timerange)
        cmd = f'$ft_binary backtesting -s $ho_strategy {self.monigomani_config.command_configs()}' \
              f'--timerange $timerange'

        if timerange is None:
            timerange = self.monigomani_config.config['timerange']

        if strategy is None:
            strategy = self.monigomani_config.config['hyperopt']['strategy']

        if enable_protections is True:
            cmd = f'{cmd} --enable-protections'

        cmd = Template(cmd).substitute(
            ft_binary=self.monigomani_config.config['ft_binary'],
            ho_strategy=strategy,
            timerange=timerange)

        if output_file_name is None:
            output_file_name = f'BackTestResults-{datetime.now().strftime("%d-%m-%Y-%H-%M-%S")}'

        output_file_path = f'{self._basedir}/user_data/backtest_results/{output_file_name}.log'
        self.monigomani_cli.run_command(cmd, output_file_path)
        MoniGoManiLogger(self._basedir).post_message(username=self.monigomani_config.config['username'],
                                                     message=f'🚀 Fresh **{strategy}** BackTest Results ⬇️',
                                                     results_path=output_file_path)
        MoniGoManiLogger(self._basedir).post_setup(config=self.monigomani_config.config, strategy=strategy,
                                                   basedir=self._basedir)

        self._logger.info('🍺 Backtesting ready... 🤑')

    def start_trader(self, dry_run: bool = True):
        """
        Start the trader. Your ultimate goal!

        :param dry_run: (bool, Optional): Use dry_run mode. Defaults to True
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Start trader')
        self._logger.info('💨 💨 💨')

        command = f'{self.monigomani_config.config["ft_binary"]} trade {self.monigomani_config.command_configs()}' \
                  f'--strategy {self.monigomani_config.config["hyperopt"]["strategy"]}'

        if dry_run is True:
            command += ' --dry-run'

        self.monigomani_cli.run_command(command)

    def __setup_telegram(self) -> bool:
        """
        Questionnaire to setup Telegram Bot

        :return bool: False if no answers are given, True if all went ok.
        """
        questions = [
            {
                'type': 'confirm',
                'message': 'Do you want to also setup your Telegram bot? ',
                'name': 'proceed_telegram',
                'default': True
            },
            {
                'type': 'confirm',
                'message': 'Do you want to enable the Telegram Bot?',
                'name': 'enable_telegram',
                'default': True,
                'when': lambda result: result['proceed_telegram']
            },
            {
                'type': 'password',
                'name': 'telegram_token',
                'message': 'Please enter your Telegram Bot token: ',
                'default': '',
                'when': lambda result: result['proceed_telegram'] and result['enable_telegram']
            },
            {
                'type': 'input',
                'name': 'telegram_chat_id',
                'message': 'Please enter the chat ID: ',
                'default': '',
                'when': lambda result: result['proceed_telegram'] and result['enable_telegram']
            }
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            return False

        if answers.get('proceed_telegram') is True:
            opt = {
                'enable_telegram': answers.get('enable_telegram'),
                'telegram_token': answers.get('telegram_token'),
                'telegram_chat_id': answers.get('telegram_chat_id')
            }

            self.monigomani_config.save_telegram_credentials(opt)

        return True


if __name__ == '__main__':
    try:
        fire.Fire(MGMHurry)
    except KeyboardInterrupt:
        print('😼 KTHXBAI')
        sys.exit(0)
