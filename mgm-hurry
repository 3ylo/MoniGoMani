#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -* vim: syntax=python -*-
# pylint: disable=W0108

#                                       _
#                                      | |
#  _ __ ___    __ _  _ __ ___   ______ | |__   _   _  _ __  _ __  _   _
# | '_ ` _ \  / _` || '_ ` _ \ |______|| '_ \ | | | || '__|| '__|| | | |
# | | | | | || (_| || | | | | |        | | | || |_| || |   | |   | |_| |
# |_| |_| |_| \__, ||_| |_| |_|        |_| |_| \__,_||_|   |_|    \__, |
#              __/ |                                               __/ |
#             |___/                                               |___/
#
# --- ↑↓ Do not remove these libs ↑↓ -----------------------------------------------------------------------------------

"""mgm-hurry is a CLI Tool for setting up and managing a Freqtrade instance containing the MoniGoMani Framework & Strategy"""

import glob
import json
import os
import sys
import logging

from datetime import datetime
from string import Template

import fire

from InquirerPy import prompt
from InquirerPy.validator import NumberValidator
from art import tprint

from user_data.mgm_tools.mgm_hurry.FreqtradeCli import FreqtradeCli
from user_data.mgm_tools.mgm_hurry.MoniGoManiCli import MoniGoManiCli
from user_data.mgm_tools.mgm_hurry.MoniGoManiConfig import MoniGoManiConfig
from user_data.mgm_tools.mgm_hurry.MoniGoManiLogger import MoniGoManiLogger

# ---- ↑ Do not remove these libs ↑ ------------------------------------------------------------------------------------

class MGMHurry:
    """
    💨 Your command is my objective 💨

    CLI Tool for setting up and managing a Freqtrade instance containing the MoniGoMani Framework & Strategy

    Attributes:
        monigomani_config   The monigomani_config object
        freqtrade_cli       The FreqtradeCli object
        _logger             The logging function out of MoniGoManiLogger
    """
    monigomani_config   : MoniGoManiConfig
    freqtrade_cli       : FreqtradeCli
    _logger             : logging

    def __init__(self):
        tprint('mgm-hurry')

        self._basedir = os.getcwd()
        self._logger = MoniGoManiLogger(self._basedir).get_logger()
        self.monigomani_config = MoniGoManiConfig(self._basedir)

        if self.monigomani_config.reload() is False:
            self._logger.error('⚠️ Failed to load or create ".hurry" config file.')

        self.freqtrade_cli = FreqtradeCli(self._basedir)
        self.monigomani_cli = MoniGoManiCli(self._basedir)

    def up(self):  # pylint: disable=invalid-name
        """
        The all in one command. Hurry up, turn it up!
        """

        questions = [
            {
                'type': 'confirm',
                'name': 'install_freqtrade',
                'message': '💨 Do you want to install Freqtrade?'
            },
            {
                'type': 'confirm',
                'name': 'install_mgm',
                'message': '💨 Do you want to install MoniGoMani?'
            },
            {
                'type': 'confirm',
                'name': 'run_setup',
                'message': '💨 Do you want to configure it now?'
            },
            {
                'type': 'confirm',
                'name': 'download_static_pairlist',
                'message': '💨 Do you want to generate a static pairlist now?'
            },
            {
                'type': 'confirm',
                'name': 'download_data',
                'message': '💨 Do you want to download candle data now?'
            },
            {
                'type': 'confirm',
                'name': 'do_hyperopt',
                'message': '💨 Do you want to hyperopt now?'
            },
            {
                'type': 'confirm',
                'name': 'do_backtest',
                'message': '💨 Do you want to backtest now?'
            },
            {
                'type': 'list',
                'name': 'start_trading',
                'message': '💨 Do you want to start trading?',
                'choices': [
                    {
                        'name': 'No',
                        'value': 0
                    }, {
                        'name': 'Yes, Dry-Run please',
                        'value': 1
                    }, {
                        'name': 'Yes, for real!',
                        'value': 2
                    }
                ]
            },
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        if answers.get('install_freqtrade') is True:
            self.install_freqtrade()

        if answers.get('install_mgm') is True:
            self.install_mgm()

        if answers.get('run_setup') is True:
            self.setup()

        if answers.get('download_static_pairlist') is True:
            self.download_static_pairlist()

        if answers.get('download_data') is True:
            self.download_candle_data()

        if answers.get('do_hyperopt') is True:
            # First HO run
            self.hyperopt()
            ho_choice = prompt(questions=[{
                'type': 'input',
                'name': 'ho_epoch',
                'message': '(HO 1) Choose the epoch which fits the best to your liking: (0-1000) ',
                'filter': lambda val: int(val),
                'validate': NumberValidator()
            }])
            self.hyperopt_apply_epoch(ho_choice.get('ho_epoch'), 1)

            # Second HO run
            self.hyperopt()
            ho_choice = prompt(questions=[{
                'type': 'input',
                'name': 'ho_epoch',
                'message': '(HO 2) Choose the epoch which fits the best to your liking: (0-1000) ',
                'filter': lambda val: int(val),
                'validate': NumberValidator()
            }])
            self.hyperopt_apply_epoch(ho_choice.get('ho_epoch'), 2)

        if answers.get('do_backtest') is True:
            self.backtest()

        if answers.get('start_trading') > 0:
            if answers.get('start_trading') == 2:
                self.start_trader(False)
            else:
                self.start_trader(True)
        else:
            self._logger.info('💨 Executing mgm-hurry up finished.')

    def install_freqtrade(self, branch: str = 'develop', target_dir: str = None):
        """
        Install Freqtrade the easy way.

        :param branch: (string, optional) Checkout a specific branch. Defaults to 'develop'.
        :param target_dir: (string, optional) Specify a target_dir to install Freqtrade. Defaults to os.getcwd().
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Install Freqtrade')
        self._logger.info('💨 💨 💨')

        # Checking Freqtrade installation to confirm for overwrite
        if self.freqtrade_cli.installation_exists() is True:
            questions = [
                {
                    'type': 'confirm',
                    'message': 'It looks like Freqtrade is already installed. Proceed to overwrite?',
                    'name': 'proceed',
                    'default': False
                },
            ]

            result = prompt(questions)

            if result.get('proceed') is False:
                self._logger.info('Skipping overwriting Freqtrade installation.')
                return False

        if target_dir is None:
            target_dir = self._basedir

        self.freqtrade_cli.download_setup_freqtrade(branch, target_dir)

        self._logger.info('🍺 Freqtrade has been installed. '
                          'You can now proceed to install MoniGoMani. (Hint: mgm-hurry install_mgm)')

        return True

    def install_mgm(self, branch: str = 'development', target_dir: str = None):
        """
        Install the MoniGoMani Framework & Strategy.

        :param branch: (string, optional) Checkout a specific branch. Defaults to 'development'.
        :param target_dir: (string, optional) Specify a target_dir to install MoniGoMani. Defaults to os.getcwd().
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Install MoniGoMani')
        self._logger.info('💨 💨 💨')

        # Checking MoniGoMani installation to confirm for overwrite
        if self.monigomani_cli.installation_exists() is True:
            questions = [
                {
                    'type': 'confirm',
                    'message': 'It looks like MoniGoMani is already installed. Proceed to overwrite?',
                    'name': 'proceed',
                    'default': False
                }
            ]

            result = prompt(questions)

            if result.get('proceed') is False:
                self._logger.info(
                    'Skipping overwriting MoniGoMani installation.')
                return False

            # Check if the private config file already exists.
            cfg_filename = self.monigomani_config.get_config_filename('mgm-config-private')

            questions = [
                {
                    'type': 'confirm',
                    'message': 'Should I print your "mgm-config-private.json" contents '
                               'so you can copy it over to new installation?',
                    'name': 'print',
                    'default': False,
                    'when': lambda result: os.path.isfile(cfg_filename)
                },
                {
                    'type': 'confirm',
                    'message': 'WARNING: You are printing sensitive information '
                               'which you should NEVER SHARE with anybody. Really proceed?',
                    'name': 'print_confirmed',
                    'default': False,
                    'when': lambda result: result['print']
                }
            ]

            result = prompt(questions)

            if result.get('print_confirmed') is True:
                # Read "mgm-config-private.json" and pretty print it
                with open(f'{self._basedir}/user_data/mgm-config-private.json', ) as mgm_private_config:
                    print(json.dumps(json.load(mgm_private_config), indent=4))

        if target_dir is None:
            target_dir = self._basedir

        self.monigomani_cli.download_setup_mgm(branch, target_dir)
        self.monigomani_config.create_config_files(self._basedir)
        self._logger.info('🍺 MoniGoMani has been installed. You can now proceed to setup your instance. (Hint: mgm-hurry setup)')

    def setup(self):
        """
        Saves setup data based on your answers
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Setup')
        self._logger.info('💨 💨 💨')

        self._logger.info('🤓 Let\'s answer some questions to make your life easier.')

        strategies = map(lambda f: os.path.basename(f).replace('.py', ''),
                         glob.glob(f'{self._basedir}/user_data/strategies/*.py'))

        strategies_choices = []
        for strat in strategies:
            if strat != 'MasterMoniGoManiHyperStrategy':
                strategies_choices.append({'name': strat, 'value': strat})

        if len(strategies_choices) == 0:
            strat_dir = f'{self._basedir}/user_data/strategies/'
            self._logger.error(f'🤷 I could not find any strategy in {strat_dir}. Did you install Freqtrade & MoniGoMani?')
            sys.exit(1)

        self.monigomani_config.create_config_files(self._basedir)

        hyperopts = map(lambda f: os.path.basename(f).replace('.py', ''),
                        glob.glob(f'{self._basedir}/user_data/hyperopts/*.py'))

        hyperopts_choices = []
        for hyperopt in hyperopts:
            hyperopts_choices.append({'name': hyperopt, 'value': hyperopt})

        if len(hyperopts_choices) == 0:
            ho_dir = f'{self._basedir}/user_data/hyperopts/'
            self._logger.error(f'🤷 I could not find any hyperopts in {ho_dir}. Did you install Freqtrade & MoniGoMani?')
            sys.exit(1)

        self.monigomani_config.reload()

        questions = [{
            'type': 'list',
            'name': 'install_type',
            'message': 'Which way you want to use Freqtrade?',
            'choices': ['docker', 'source'],
            'default': self.monigomani_config.get('install_type') or 'source'
        }, {
            'type': 'input',
            'name': 'timerange',
            'message': 'Please enter the default timerange you want to use:',
            'default': self.monigomani_config.get('timerange') or '20210501-20210616'
        }, {
            'type': 'list',
            'name': 'ho_strategy',
            'message': 'Which HyperOpt Strategy do you want to use?',
            'choices': strategies_choices,
            'default': self.monigomani_config.get('hyperopt')['strategy'] or 'MoniGoManiHyperStrategy'
        }, {
            'type': 'list',
            'name': 'ho_loss',
            'message': 'Which HyperOpt Loss do you want to use?',
            'choices': hyperopts_choices,
            'default': self.monigomani_config.get('hyperopt')['loss'] or 'WinRatioAndProfitRatioLoss'
        }, {
            'type': 'checkbox',
            'name': 'ho_spaces',
            'message': 'Which spaces do you want to HyperOpt?',
            'choices': map(
                lambda x: {'enabled': True, 'name': x['name'], 'value': x['value']}
                if x['value'] in self.monigomani_config.get('hyperopt')['spaces'].split(' ')
                else {'enabled': False, 'name': x['name'], 'value': x['value']},
                [
                    {'enabled': False, 'name': 'default', 'value': 'default'},
                    {'enabled': False, 'name': 'buy', 'value': 'buy'},
                    {'enabled': False, 'name': 'sell', 'value': 'sell'},
                    {'enabled': False, 'name': 'roi', 'value': 'roi'},
                    {'enabled': False, 'name': 'stoploss', 'value': 'stoploss'},
                    {'enabled': False, 'name': 'trailing', 'value': 'trailing'},
                    {'enabled': False, 'name': 'all', 'value': 'all'}
                ]
            ),
            'filter': lambda val: ' '.join(val)
        }, {
            'type': 'input',
            'name': 'ho_quotation',
            'message': 'Please enter the default quotation you want to use:',
            'default': self.monigomani_config.get('hyperopt')['quote'] or 'USDT'
        }, {
            'type': 'input',
            'name': 'ho_epochs',
            'message': 'Please enter the amount of epochs you want to HyperOpt:',
            'default': str(self.monigomani_config.get('hyperopt')['epochs']) or '1000',
            'filter': lambda val: int(val)
        }, {
            'type': 'confirm',
            'message': 'Do you want to also setup your exchange?',
            'name': 'proceed_exchange',
            'default': True,
        }, {
            'type': 'list',
            'name': 'exchange',
            'message': 'Which exchange do you want to use?',
            'choices': ['binance', 'ftx', 'bittrex'],
            'when': lambda result: result['proceed_exchange']
        }, {
            'type': 'password',
            'name': 'api_key',
            'message': 'Please enter the exchange API key: ',
            'when': lambda result: result['proceed_exchange']
        }, {
            'type': 'password',
            'name': 'api_secret',
            'message': 'Please enter the exchange API secret: ',
            'when': lambda result: result['proceed_exchange']
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit(1)

        if answers.get('install_type') == 'source':
            ft_binary = f'source {self._basedir}/.env/bin/activate; freqtrade'
        else:
            ft_binary = 'docker-compose run --rm freqtrade'

        new_config = {
            'config': {
                'install_type': answers.get('install_type'),
                'ft_binary': ft_binary,
                'timerange': answers.get('timerange'),
                'exchange': answers.get('exchange') or 'none',
                'hyperopt': {
                    'strategy': answers.get('ho_strategy'),
                    'loss': answers.get('ho_loss'),
                    'spaces': answers.get('ho_spaces') or 'default',
                    'quote': answers.get('ho_quotation'),
                    'epochs': answers.get('ho_epochs')
                },
                'mgm_config_names': {
                    'mgm-config': 'mgm-config.json',
                    'mgm-config-private': 'mgm-config-private.json',
                    'mgm-config-hyperopt': 'mgm-config-hyperopt.json'
                }
            }
        }

        self.monigomani_config.write(new_config)

        if answers.get('proceed_exchange') is True:
            cred = {
                'exchange': answers.get('exchange'),
                'api_key': answers.get('api_key'),
                'api_secret': answers.get('api_secret'),
            }

            self.monigomani_config._save_exchange_credentials(cred)

        self.__setup_telegram()

    def cleanup(self):
        """
        Deletes stored hyperopt config from previous run(s)
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Cleanup')
        self._logger.info('💨 💨 💨')

        self._logger.info('👉 Removing "mgm-config-hyperopt.json"')
        mgm_config_hyperopt_path = f'{self._basedir}/user_data/mgm-config-hyperopt.json'

        if os.path.exists(mgm_config_hyperopt_path):
            os.remove(mgm_config_hyperopt_path)

        self._logger.info('👉 Removing "MoniGoManiHyperStrategy.json"')
        mgm_strategy_config_hyperopt_path = f'{self._basedir}./user_data/strategies/MoniGoManiHyperStrategy.json'

        if os.path.exists(mgm_strategy_config_hyperopt_path):
            os.remove(mgm_strategy_config_hyperopt_path)

        self._logger.info('🍺 Reset successful, MoniGoMani HyperOpt configs removed...')

    def download_candle_data(self, timerange: str = None):
        """
        Downloads candle data for the given timerange.

        :param timerange: (string, optional) Timerange from/to in string format (start-end): yyyymmdd-yyyymmdd.
            Defaults to timerange out of ".hurry" config file. -or- for preset timerange: down, side, up
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Download candle data')
        self._logger.info('💨 💨 💨')

        if self.monigomani_config.reload() is False:
            self._logger.error('🤷 No Hurry config file found. Please run: mgm-hurry setup')
            sys.exit(1)

        timerange = self.monigomani_config._get_preset_timerange(timerange)

        if self.freqtrade_cli.installation_exists() is False:
            self._logger.error('🤷 No Freqtrade installation found. I crash.')

        questions = [{
            'type': 'input',
            'name': 'timerange',
            'message': 'Please enter the timerange you want to use: ',
            'default': timerange
        }, {
            'type': 'checkbox',
            'name': 'tickers',
            'message': 'Specify which tickers to download: ',
            'choices': [
                {'name': '1m', 'value': '1m', 'enabled': False},
                {'name': '3m', 'value': '3m', 'enabled': False},
                {'name': '5m', 'value': '5m', 'enabled': True},
                {'name': '15m', 'value': '15m', 'enabled': False},
                {'name': '30m', 'value': '30m', 'enabled': True},
                {'name': '1h', 'value': '1h', 'enabled': False},
                {'name': '2h', 'value': '2h', 'enabled': False},
                {'name': '4h', 'value': '4h', 'enabled': False},
                {'name': '6h', 'value': '6h', 'enabled': False},
                {'name': '8h', 'value': '8h', 'enabled': False},
                {'name': '12h', 'value': '12h', 'enabled': False},
                {'name': '1d', 'value': '1d', 'enabled': False},
                {'name': '3d', 'value': '3d', 'enabled': False},
                {'name': '1w', 'value': '1w', 'enabled': False},
                {'name': '2w', 'value': '2w', 'enabled': False},
                {'name': '1M', 'value': '1M', 'enabled': False},
                {'name': '1y', 'value': '1y', 'enabled': False}
            ],
            'validate': lambda result: len(result) >= 1,
            'invalid_message': 'should be at least 1 selection',
            'instruction': '(select at least 1)',
            'filter': lambda val: ' '.join(val)
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        timerange = answers.get('timerange')
        tickers = answers.get('tickers')

        self._logger.info(
            f'👉 Downloading candle data ({tickers}) for timerange {timerange}')

        dcd = f'{self.monigomani_config.config["ft_binary"]} download-data --timerange {timerange} \
              -t {tickers} -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json'

        self._logger.debug(dcd)

        self.monigomani_cli.run_command(dcd)

        self._logger.info('🍺 Downloading candle data finished.')

    def download_static_pairlist(self):
        """
        Downloads StaticPairList and saves into mgm_pair_lists folder.

        :return None
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Download Top Volume Static Pairlist')
        self._logger.info('💨 💨 💨')

        if self.monigomani_config.reload() is False:
            self._logger.error('🤷 No Hurry config file found. Please run: mgm-hurry setup')
            sys.exit(1)

        if self.freqtrade_cli.installation_exists() is False:
            self._logger.error('🤷 Whaaaa.. No Freqtrade installation found. Beats me...')
            sys.exit(1)

        # Download and generate a static pairlist
        self._logger.info('🤖 Generating new static pairlist...')
        quote = self.monigomani_config.config['hyperopt']['quote']
        exchange = self.monigomani_config.config['exchange'].title()
        static_pairlist = self.freqtrade_cli.download_static_pairlist(quote, exchange)

        # Save new static pairlist to his own pairlist json file
        self._logger.info('🤖 Saving fresh static pairlist into mgm_pair_lists/...')
        with open(
            '{0}/user_data/mgm_pair_lists/{1}-{2}-Top-Volume-StaticPairList.json'.format(self._basedir, exchange, quote), 'w+'
            ) as pairlist_file:
            data_format = {'exchange': {'pair_whitelist': static_pairlist}}
            json.dump(data_format, pairlist_file, indent=4)

        self._logger.info('🍺 Saving pairlist as whitelist to "mgm-config.json"...')
        # Overwrite the new static pairlist to the exchange config in mgm-config[exchange][pair_whitelist]
        mgm_config_file = self.monigomani_config.get_config_filename('mgm-config')
        with open(mgm_config_file, ) as mgm_config:
            try:
                mgm_config_object = json.load(mgm_config)
            except Exception:
                mgm_config_object = {'exchange': {'pair_whitelist': []}}
            mgm_config.close()

        with open(mgm_config_file, 'w') as mgm_config:
            mgm_config_object['exchange']['pair_whitelist'] = static_pairlist
            json.dump(mgm_config_object, mgm_config, indent=4)
            mgm_config.close()

    def hyperopt(self, timerange: str = None, strategy: str = None, spaces: str = None, enable_protections: bool = True,
                 random_state: int = None, apply_best_results: bool = True, clean_start: bool = False,
                 output_file_name: str = None):
        """
        HyperOpt Magic. Runs HyperOpt process to find out the most positive settings.

        :param timerange: (str, Optional): timerange from/to in format (start-end): yyyymmdd-yyyymmdd
            or preset [up, down, side]. Defaults to value in '.hurry'
        :param strategy: (str, Optional): Hyper Opt strategy to use. Defaults to value in '.hurry'
        :param spaces: (str, Optional): Spaces (space delimited) to optimize
            for [default, all, buy, sell, roi, stoploss, etc]. Defaults to value in '.hurry'
        :param enable_protections: (bool, Optional): Add '--enable-protections' flag to HO-command. Defaults to True.
        :param random_state: (int, Optional): Add '--random-state random_state' flag to HO-command. Defaults to None.
        :param apply_best_results: (bool, Optional): Apply 'best' HO results direct after HO? Defaults to True.
        :param clean_start: (bool, Optional): Cleanup MoniGoMani before starting the HO? Defaults to False.
        :param output_file_name: (str, Optional) Name of the '.log' file.
            Defaults to 'HyperOptResults-<Current-DateTime>.log'
        """

        if clean_start is True:
            self.cleanup()

        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Starting HyperOpt run. Keep calm while your computer burns 🔥')
        self._logger.info('💨 💨 💨')

        timerange = self.monigomani_config._get_preset_timerange(timerange)

        if strategy is None:
            strategy = self.monigomani_config.config['hyperopt']['strategy']

        if spaces is None:
            spaces = self.monigomani_config.config['hyperopt']['spaces']

        cmd = '$ft_binary hyperopt -s $ho_strategy \
              -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json \
              --hyperopt-loss $ho_loss --spaces $ho_spaces -e $ho_epochs --timerange $timerange '

        if enable_protections is True:
            cmd = f'{cmd.strip()} --enable-protections'

        if random_state is not None:
            cmd = f'{cmd.strip()} --random-state $random_state'

        # Execute freqtrade hyperopt command. Will take some time!
        cmd = Template(cmd).substitute(
            ft_binary=self.monigomani_config.config['ft_binary'],
            ho_strategy=strategy,
            ho_loss=self.monigomani_config.config['hyperopt']['loss'],
            ho_spaces=spaces,
            ho_epochs=self.monigomani_config.config['hyperopt']['epochs'],
            timerange=timerange,
            random_state=random_state)

        self._logger.debug(cmd)

        if output_file_name is None:
            output_file_name = '{0}/user_data/hyperopt_results/HyperOptResults-{1}.log'.format(self._basedir, datetime.now().strftime('%d-%m-%Y-%H-%M-%S'))

        self.monigomani_cli.run_command(cmd, output_file_name)

        if apply_best_results is True:
            self.monigomani_cli.apply_best_results(strategy)

        self._logger.info('🍺 HyperOpt run ready... 🥵')

    def hyperopt_show_results(self, only_best: bool = True, only_profitable: bool = False):
        """
        Show hyperopt results after choosing a .fthypt file.

        :param only_best: (bool, Optional); Show only best epochs. Defaults to True.
        :param only_profitable: (bool, Optional); Show only profitable epochs. Defaults to False.
        """

        fthypts = map(os.path.basename,
                      sorted(
                          glob.glob(f'{self._basedir}/user_data/hyperopt_results/*.fthypt'),
                          key=os.path.getmtime, reverse=True))

        dat = list(fthypts)

        if len(dat) == 0:
            self._logger.warning('Whoops, no hyperopt results could be found.')
            sys.exit(1)

        questions = [
            {
                'type': 'list',
                'name': 'fthypt_file',
                'message': 'Please select the hyperopt results you want to show: ',
                'choices': dat
            },
        ]

        answers = prompt(questions=questions)

        choice = answers.get('fthypt_file')

        self._logger.info(f'👉 Showing hyperopt results for: {choice}')

        best = '--best' if only_best is True else ''
        profit = '--profitable' if only_profitable is True else ''

        dcd = f'{self.monigomani_config.config["ft_binary"]} hyperopt-list --hyperopt-filename "{choice}" {best} {profit}'
        self._logger.debug(dcd)

        self.monigomani_cli.run_command(dcd)

    def hyperopt_show_epoch(self, epoch: int = 0):
        """
        Shows the HyperOpt results for given epoch.

        :param epoch: (int) The epoch number to show the results from.
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Hyperopt show results')
        self._logger.info('💨 💨 💨')

        if epoch == 0:
            self._logger.error('🤷 Please pass the epoch number through. Hint: mgm-hurry hyperopt_show_epoch --epoch=837')
            sys.exit(1)

        self._logger.info('👉 Showing HyperOpt results for epoch # {epoch}')

        self.monigomani_cli.run_command(f'{self.monigomani_config.config["ft_binary"]} hyperopt-show -n {epoch}')

    def hyperopt_apply_epoch(self, epoch: int = 0, run: int = 1):
        """
        Apply HyperOpt results from given epoch

        :param epoch: (int): The epoch number to apply the results from.
        :param run: (int, Optional): Defaults to 1. Run number of hyperopt. First run has different command than second.
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Hyperopt apply epoch')
        self._logger.info('💨 💨 💨')

        if epoch == 0:
            self._logger.error('🤷 Please pass the epoch number through. Hint: mgm-hurry hyperopt_apply_epoch --epoch=837')
            sys.exit(1)

        self._logger.info(f'👉 Applying HyperOpt results of epoch # {epoch}')

        # View & Apply HyperOpt Results from a trusted <epoch of choice>:
        self.monigomani_cli.run_command(
            (f'{self.monigomani_config.config["ft_binary"]} hyperopt-show -n {epoch} -c ./user_data/mgm-config.json '
             '-c ./user_data/mgm-config-private.json  && '
             'mv ./user_data/strategies/MoniGoManiHyperStrategy.json ./user_data/mgm-config-hyperopt.json')
        )

        self._logger.info(f'🍺 Hyperopt results of epoch # {epoch} are applied.')

    def backtest(self, timerange: str = None, enable_protections: bool = True):
        """
        Run a backtest session.

        :param timerange: (string, Optional): The target timerange for backtesting. Defaults to None.
        :param enable_protections: (bool, Optional): Whether or not to enable protections. Defaults to True.
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Start backtesting. Lets see how it all turns out!')
        self._logger.info('💨 💨 💨')

        timerange = self.monigomani_config._get_preset_timerange(timerange)

        cmd = ('$ft_binary backtesting -s $ho_strategy -c ./user_data/mgm-config.json '
               '-c ./user_data/mgm-config-private.json --timerange $timerange')

        if enable_protections is True:
            cmd = f'{cmd} --enable-protections'

        cmd = Template(cmd).substitute(
            ft_binary=self.monigomani_config.config['ft_binary'],
            ho_strategy=self.monigomani_config.config['hyperopt']['strategy'],
            timerange=timerange)

        self.monigomani_cli.run_command(cmd)

        self._logger.info('🍺 Backtesting ready... 🤑')

    def start_trader(self, dry_run: bool = False):
        """
        Start the trader. Your ultimate goal!

        :param dry_run: (bool, Optional): Use dry_run mode. Defaults to False
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Start trader')
        self._logger.info('💨 💨 💨')

        cmd = (
            f'{self.monigomani_config.config["ft_binary"]} trade -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json \
            -c ./user_data/mgm-config-hyperopt.json --strategy {self.monigomani_config.config["hyperopt"]["strategy"]}'
        )

        if dry_run is True:
            cmd = f'{cmd} --dry-run'

        self.monigomani_cli.run_command(cmd)

    def __setup_telegram(self) -> bool:
        """
        Questionnaire to setup Telegram Bot

        :return bool: False if no answers are given, True if all went ok.
        """
        questions = [
            {
                'type': 'confirm',
                'message': 'Do you want to also setup your Telegram bot? ',
                'name': 'proceed_telegram',
                'default': True,
            },
            {
                'type': 'confirm',
                'message': 'Do you want to enable the Telegram Bot?',
                'name': 'enable_telegram',
                'default': True,
                'when': lambda result: result['proceed_telegram']
            },
            {
                'type': 'password',
                'name': 'telegram_token',
                'message': 'Please enter your Telegram Bot token: ',
                'default': '',
                'when': lambda result: result['proceed_telegram'] and result['enable_telegram']
            },
            {
                'type': 'input',
                'name': 'telegram_chat_id',
                'message': 'Please enter the chat ID: ',
                'default': '',
                'when': lambda result: result['proceed_telegram'] and result['enable_telegram']
            },
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            return False

        if answers.get('proceed_telegram') is True:
            opt = {
                'enable_telegram': answers.get('enable_telegram'),
                'telegram_token': answers.get('telegram_token'),
                'telegram_chat_id': answers.get('telegram_chat_id')
            }

            self.monigomani_config._save_telegram_credentials(opt)

        return True


if __name__ == '__main__':
    try:
        fire.Fire(MGMHurry)
    except KeyboardInterrupt:
        print('😼 KTHXBAI')
        sys.exit(0)
