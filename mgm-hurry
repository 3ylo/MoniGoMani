#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -* vim: syntax=python -*-
#                                       _
#                                      | |
#  _ __ ___    __ _  _ __ ___   ______ | |__   _   _  _ __  _ __  _   _
# | '_ ` _ \  / _` || '_ ` _ \ |______|| '_ \ | | | || '__|| '__|| | | |
# | | | | | || (_| || | | | | |        | | | || |_| || |   | |   | |_| |
# |_| |_| |_| \__, ||_| |_| |_|        |_| |_| \__,_||_|   |_|    \__, |
#              __/ |                                               __/ |
#             |___/                                               |___/
#
# --- ↑↓ Do not remove these libs ↑↓ -----------------------------------------------------------------------------------
import glob
import json
import os
import sys
import tempfile
from datetime import datetime
from string import Template

import fire
import yaml
from InquirerPy import prompt
from InquirerPy.validator import NumberValidator
from art import tprint

from user_data.mgm_tools.mgm_hurry.FreqtradeCli import FreqtradeCli
from user_data.mgm_tools.mgm_hurry.MoniGoManiCli import MoniGoManiCli
from user_data.mgm_tools.mgm_hurry.MoniGoManiConfig import MoniGoManiConfig
from user_data.mgm_tools.mgm_hurry.MoniGoManiLogger import get_logger

# ---- ↑ Do not remove these libs ↑ ------------------------------------------------------------------------------------

class MGMHurry:
    """
    💨 Your command is my objective 💨

    CLI Tool for setting up and managing a Freqtrade instance containing the MoniGoMani Framework & Strategy
    """

    monigomani_config: MoniGoManiConfig
    freqtrade_cli: str

    def __init__(self):
        tprint('mgm-hurry')

        self._basedir = os.getcwd()
        self._logger = get_logger()
        self.monigomani_config = MoniGoManiConfig(self._basedir, self._logger)

        if self.monigomani_config.reload() is False:
            self._logger.error('⚠️ Failed to load or create ".hurry" config file.')

        self.freqtrade_cli = FreqtradeCli(self._basedir, self._logger)
        self.monigomani_cli = MoniGoManiCli(self._basedir, self._logger)

    def up(self):  # pylint: disable=invalid-name
        """
        The all in one command. Hurry up, turn it up!
        """

        questions = [
            {
                'type': 'confirm',
                'name': 'install_freqtrade',
                'message': '💨 Do you want to install Freqtrade?'
            },
            {
                'type': 'confirm',
                'name': 'install_mgm',
                'message': '💨 Do you want to install MoniGoMani?'
            },
            {
                'type': 'confirm',
                'name': 'run_setup',
                'message': '💨 Do you want to configure it now?'
            },
            {
                'type': 'confirm',
                'name': 'download_static_pairlist',
                'message': '💨 Do you want to generate a static pairlist now?'
            },
            {
                'type': 'confirm',
                'name': 'download_data',
                'message': '💨 Do you want to download candle data now?'
            },
            {
                'type': 'confirm',
                'name': 'do_hyperopt',
                'message': '💨 Do you want to hyperopt now?'
            },
            {
                'type': 'confirm',
                'name': 'do_backtest',
                'message': '💨 Do you want to backtest now?'
            },
            {
                'type': 'list',
                'name': 'start_trading',
                'message': '💨 Do you want to start trading?',
                'choices': [
                    {
                        'name': 'No',
                        'value': 0
                    }, {
                        'name': 'Yes, Dry-Run please',
                        'value': 1
                    }, {
                        'name': 'Yes, for real!',
                        'value': 2
                    }
                ]
            },
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        if answers.get('install_freqtrade') is True:
            self.install_freqtrade()

        if answers.get('install_mgm') is True:
            self.install_mgm()

        if answers.get('run_setup') is True:
            self.setup()

        if answers.get('download_static_pairlist') is True:
            self.download_static_pairlist()

        if answers.get('download_data') is True:
            self.download_candle_data()

        if answers.get('do_hyperopt') is True:
            # First HO run
            self.hyperopt()
            ho_choice = prompt(questions=[{
                'type': 'input',
                'name': 'ho_epoch',
                'message': '(HO 1) Choose the epoch which fits the best to your liking: (0-1000) ',
                'filter': lambda val: int(val),
                'validate': NumberValidator()
            }])
            self.hyperopt_apply_epoch(ho_choice.get('ho_epoch'), 1)

            # Second HO run
            self.hyperopt()
            ho_choice = prompt(questions=[{
                'type': 'input',
                'name': 'ho_epoch',
                'message': '(HO 2) Choose the epoch which fits the best to your liking: (0-1000) ',
                'filter': lambda val: int(val),
                'validate': NumberValidator()
            }])
            self.hyperopt_apply_epoch(ho_choice.get('ho_epoch'), 2)

        if answers.get('do_backtest') is True:
            self.backtest()

        if answers.get('start_trading') > 0:
            if answers.get('start_trading') == 2:
                self.start_trader(False)
            else:
                self.start_trader(True)
        else:
            self._logger.info('💨 Executing mgm-hurry up finished.')

    def install_freqtrade(self, branch: str = 'develop', target_dir: str = None):
        """
        Install Freqtrade the easy way.

        :param branch: (string, optional) Checkout a specific branch. Defaults to 'develop'.
        :param target_dir: (string, optional) Specify a target_dir to install Freqtrade. Defaults to os.getcwd().
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Install Freqtrade')
        self._logger.info('💨 💨 💨')

        # Checking Freqtrade installation to confirm for overwrite
        if self.freqtrade_cli.installation_exists() is True:
            questions = [
                {
                    'type': 'confirm',
                    'message': 'It looks like Freqtrade is already installed. Proceed to overwrite?',
                    'name': 'proceed',
                    'default': False
                },
            ]

            result = prompt(questions)

            if result.get('proceed') is False:
                sys.exit(1)

        if target_dir is None:
            target_dir = self._basedir

        self.freqtrade_cli.download_setup_freqtrade(branch, target_dir)

        self._logger.info('🍺 Freqtrade has been installed. '
                          'You can now proceed to install MoniGoMani. (Hint: mgm-hurry install_mgm)')

    def install_mgm(self, branch: str = 'development', target_dir: str = None):
        """
        Install the MoniGoMani Framework & Strategy.

        :param branch: (string, optional) Checkout a specific branch. Defaults to 'development'.
        :param target_dir: (string, optional) Specify a target_dir to install MoniGoMani. Defaults to os.getcwd().
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Install MoniGoMani')
        self._logger.info('💨 💨 💨')

        # Checking MoniGoMani installation to confirm for overwrite
        if self.monigomani_cli.installation_exists() is True:
            questions = [
                {
                    'type': 'confirm',
                    'message': 'It looks like MoniGoMani is already installed. Proceed to overwrite?',
                    'name': 'proceed',
                    'default': False
                }
            ]

            result = prompt(questions)

            if result.get('proceed') is False:
                sys.exit(1)

            questions = [
                {
                    'type': 'confirm',
                    'message': 'Should I print your "mgm-config-private.json" contents '
                               'so you can copy it over to new installation?',
                    'name': 'print',
                    'default': False
                },
                {
                    'type': 'confirm',
                    'message': 'WARNING: You are printing sensitive information '
                               'which you should NEVER SHARE with anybody. Really proceed?',
                    'name': 'print_confirmed',
                    'default': False,
                    'when': lambda result: result['print']
                }
            ]

            result = prompt(questions)

            if result.get('print_confirmed') is True:
                # Read "mgm-config-private.json" and pretty print it
                with open(f'{self._basedir}/user_data/mgm-config-private.json', ) as mgm_private_config:
                    print(json.dumps(json.load(mgm_private_config), indent=4))

        if target_dir is None:
            target_dir = self._basedir

        with tempfile.TemporaryDirectory() as temp_dirname:
            self.monigomani_cli._exec_cmd(f'git clone -b {branch} https://github.com/Rikj000/MoniGoMani.git {temp_dirname}')

            self.monigomani_cli._exec_cmd(f'cp -rf {temp_dirname}/user_data/* {target_dir}/user_data/')

            self.monigomani_cli.create_config_files(target_dir)

            self._logger.info(
                '🍺 MoniGoMani has been installed. You can now proceed to setup your instance. (Hint: mgm-hurry setup)'
            )

    def setup(self):
        """
        Saves setup data based on your answers
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Setup')
        self._logger.info('💨 💨 💨')

        self._logger.info('🤓 Let\'s answer some questions to make your life easier.')

        strategies = map(lambda f: os.path.basename(f).replace('.py', ''),
                         glob.glob(f'{self._basedir}/user_data/strategies/*.py'))

        strategies_choices = []
        for strat in strategies:
            if strat != 'MasterMoniGoManiHyperStrategy':
                strategies_choices.append({'name': strat, 'value': strat})

        if len(strategies_choices) == 0:
            strat_dir = f'{self._basedir}/user_data/strategies/'
            self._logger.error(f'🤷 I could not find any strategy in {strat_dir}. Did you install Freqtrade & MoniGoMani?')
            sys.exit(1)

        self.monigomani_cli.create_config_files(self._basedir)

        hyperopts = map(lambda f: os.path.basename(f).replace('.py', ''),
                        glob.glob(f'{self._basedir}/user_data/hyperopts/*.py'))

        hyperopts_choices = []
        for hyperopt in hyperopts:
            hyperopts_choices.append({'name': hyperopt, 'value': hyperopt})

        if len(hyperopts_choices) == 0:
            ho_dir = f'{self._basedir}/user_data/hyperopts/'
            self._logger.error(f'🤷 I could not find any hyperopts in {ho_dir}. Did you install Freqtrade & MoniGoMani?')
            sys.exit(1)

        self.monigomani_config.reload()

        questions = [{
            'type': 'list',
            'name': 'install_type',
            'message': 'Which way you want to use Freqtrade?',
            'choices': ['docker', 'source'],
            'default': self.monigomani_config.get('install_type') or 'source'
        }, {
            'type': 'input',
            'name': 'timerange',
            'message': 'Please enter the default timerange you want to use',
            'default': self.monigomani_config.get('timerange') or '20210501-20210616'
        }, {
            'type': 'list',
            'name': 'ho_strategy',
            'message': 'Which HyperOpt Strategy do you want to use?',
            'choices': strategies_choices,
            'default': self.monigomani_config.get('hyperopt')['strategy'] or 'MoniGoManiHyperStrategy'
        }, {
            'type': 'list',
            'name': 'ho_loss',
            'message': 'Which HyperOpt Loss do you want to use?',
            'choices': hyperopts_choices,
            'default': self.monigomani_config.get('hyperopt')['loss'] or 'WinRatioAndProfitRatioLoss'
        }, {
            'type': 'checkbox',
            'name': 'ho_spaces',
            'message': 'Which spaces do you want to HyperOpt?',
            'choices': map(
                lambda x: {'enabled': True, 'name': x['name'], 'value': x['value']}
                if x['value'] in self.monigomani_config.get('hyperopt')['spaces'].split(' ')
                else {'enabled': False, 'name': x['name'], 'value': x['value']},
                [
                    {'enabled': False, 'name': 'default', 'value': 'default'},
                    {'enabled': False, 'name': 'buy', 'value': 'buy'},
                    {'enabled': False, 'name': 'sell', 'value': 'sell'},
                    {'enabled': False, 'name': 'roi', 'value': 'roi'},
                    {'enabled': False, 'name': 'stoploss', 'value': 'stoploss'},
                    {'enabled': False, 'name': 'trailing', 'value': 'trailing'},
                    {'enabled': False, 'name': 'all', 'value': 'all'}
                ]
            ),
            'filter': lambda val: ' '.join(val)
        }, {
            'type': 'input',
            'name': 'ho_quotation',
            'message': 'Please enter the default quotation you want to use',
            'default': self.monigomani_config.get('hyperopt')['quote'] or 'USDT'
        }, {
            'type': 'input',
            'name': 'ho_epochs',
            'message': 'Please enter the amount of epochs you want to HyperOpt',
            'default': str(self.monigomani_config.get('hyperopt')['epochs']) or '1000',
            'filter': lambda val: int(val)
        }, {
            'type': 'confirm',
            'message': 'Do you want to also setup your exchange?',
            'name': 'proceed_exchange',
            'default': True,
        }, {
            'type': 'list',
            'name': 'exchange',
            'message': 'Which exchange do you want to use?',
            'choices': ['binance', 'ftx', 'bittrex'],
            'when': lambda result: result['proceed_exchange']
        }, {
            'type': 'password',
            'name': 'api_key',
            'message': 'Please enter the exchange API key',
            'when': lambda result: result['proceed_exchange']
        }, {
            'type': 'password',
            'name': 'api_secret',
            'message': 'Please enter the exchange API secret: ',
            'when': lambda result: result['proceed_exchange']
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit(1)

        # FIXME
        if answers.get('install_type') == 'source':
            ft_binary = f'source {self._basedir}/.env/bin/activate; freqtrade'
        else:
            ft_binary = 'docker-compose run --rm freqtrade'

        new_config = {
            'config': {
                'install_type': answers.get('install_type'),
                'ft_binary': ft_binary,
                'timerange': answers.get('timerange'),
                'exchange': answers.get('exchange') or 'none',
                'hyperopt': {
                    'strategy': answers.get('ho_strategy'),
                    'loss': answers.get('ho_loss'),
                    'spaces': answers.get('ho_spaces') or 'default',
                    'quote': answers.get('ho_quotation'),
                    'epochs': answers.get('ho_epochs')
                }
            }
        }

        self.monigomani_config.write(new_config)

        if answers.get('proceed_exchange') is True:
            cred = {
                'exchange': answers.get('exchange'),
                'api_key': answers.get('api_key'),
                'api_secret': answers.get('api_secret'),
            }

            self._save_exchange_credentials(cred)

        self.__setup_telegram()

    def cleanup(self):
        """
        Deletes stored hyperopt config from previous run(s)
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Cleanup')
        self._logger.info('💨 💨 💨')

        self._logger.info('👉 Removing "mgm-config-hyperopt.json"')
        mgm_config_hyperopt_path = f'{self._basedir}/user_data/mgm-config-hyperopt.json'

        if os.path.exists(mgm_config_hyperopt_path):
            os.remove(mgm_config_hyperopt_path)

        self._logger.info('👉 Removing "MoniGoManiHyperStrategy.json"')
        mgm_strategy_config_hyperopt_path = f'{self._basedir}./user_data/strategies/MoniGoManiHyperStrategy.json'

        if os.path.exists(mgm_strategy_config_hyperopt_path):
            os.remove(mgm_strategy_config_hyperopt_path)

        self._logger.info('🍺 Reset successful, MoniGoMani HyperOpt configs removed...')

    def download_candle_data(self, timerange: str = None):
        """
        Downloads candle data for the given timerange.

        :param timerange: (string, optional) Timerange from/to in string format (start-end): yyyymmdd-yyyymmdd.
            Defaults to timerange out of ".hurry" config file. -or- for preset timerange: down, side, up
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Download candle data')
        self._logger.info('💨 💨 💨')

        if self.monigomani_config.reload() is False:
            self._logger.error('🤷 No Hurry config file found. Please run: mgm-hurry setup')
            sys.exit(1)

        timerange = self.__get_preset_timerange(timerange)

        if self.freqtrade_cli.installation_exists() is False:
            self._logger.error('🤷 No Freqtrade installation found. I crash.')

        questions = [{
            'type': 'input',
            'name': 'timerange',
            'message': 'Please enter the timerange you want to use: ',
            'default': timerange
        }, {
            'type': 'checkbox',
            'name': 'tickers',
            'message': 'Specify which tickers to download: ',
            'choices': [
                {'name': '1m', 'value': '1m', 'enabled': False},
                {'name': '3m', 'value': '3m', 'enabled': False},
                {'name': '5m', 'value': '5m', 'enabled': True},
                {'name': '15m', 'value': '15m', 'enabled': False},
                {'name': '30m', 'value': '30m', 'enabled': False},
                {'name': '1h', 'value': '1h', 'enabled': True},
                {'name': '2h', 'value': '2h', 'enabled': False},
                {'name': '4h', 'value': '4h', 'enabled': False},
                {'name': '6h', 'value': '6h', 'enabled': False},
                {'name': '8h', 'value': '8h', 'enabled': False},
                {'name': '12h', 'value': '12h', 'enabled': False},
                {'name': '1d', 'value': '1d', 'enabled': False},
                {'name': '3d', 'value': '3d', 'enabled': False},
                {'name': '1w', 'value': '1w', 'enabled': False},
                {'name': '2w', 'value': '2w', 'enabled': False},
                {'name': '1M', 'value': '1M', 'enabled': False},
                {'name': '1y', 'value': '1y', 'enabled': False}
            ],
            'validate': lambda result: len(result) >= 1,
            'invalid_message': 'should be at least 1 selection',
            'instruction': '(select at least 1)',
            'filter': lambda val: ' '.join(val)
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        timerange = answers.get('timerange')
        tickers = answers.get('tickers')

        self._logger.info(
            f'👉 Downloading candle data ({tickers}) for timerange {timerange}')

        dcd = f'{self.monigomani_config.config["ft_binary"]} download-data --timerange {timerange} \
              -t {tickers} -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json'

        self.monigomani_cli._exec_cmd(dcd)

        self._logger.info('🍺 Downloading candle data finished.')

    def download_static_pairlist(self):
        """
        Downloads StaticPairList and saves into mgm_pair_lists folder.

        Fixme:
            * Temporary disabled due to nasty bug
            && jq 'del(.exchange.pair_whitelist )' ./user_data/mgm-config.json > ./tmp.json && jq -s '.[0] * .[1]'
                ./tmp.json ./user_data/mgm_pair_lists/$exchange-$hyperopt_quote-Top-Volume-StaticPairList.json >
                ./user_data/mgm-config.json && rm ./tmp.json && jq '.' ./user_data/mgm-config.json"
            * Catch errors
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Computing Top Volume Static Pairlist')
        self._logger.info('💨 💨 💨')

        if self.monigomani_config.reload() is False:
            self._logger.error('🤷 No Hurry config file found. Please run: mgm-hurry setup')
            sys.exit(1)

        if self.freqtrade_cli.installation_exists() is False:
            self._logger.error('🤷 Whaaaa.. No Freqtrade installation found. Beats me...')
            sys.exit(1)

        target_file = '$basedir/user_data/mgm_pair_lists/$exchange-$hyperopt_quote-Top-Volume-StaticPairList.json'
        target_file = Template(target_file).substitute(
            basedir=self._basedir,
            exchange=self.monigomani_config.config['exchange'].title(),
            hyperopt_quote=self.monigomani_config.config['hyperopt']['quote'])

        cmd_str = '$ft_binary test-pairlist -c ./user_data/mgm_tools/$exchange-Retrieve-Top-Volume-StaticPairList.json \
            --quote $hyperopt_quote --print-json | tail -n 1 | jq ".| $exchange_placeholder" > $target_file'

        cmd_str = Template(cmd_str).substitute(
            ft_binary=self.monigomani_config.config['ft_binary'],
            exchange=self.monigomani_config.config['exchange'].title(),
            hyperopt_quote=self.monigomani_config.config['hyperopt']['quote'],
            exchange_placeholder='{exchange: {pair_whitelist: .}}',
            target_file=target_file)

        self.monigomani_cli._exec_cmd(cmd_str)

        self._logger.info('🍺 Writing pairlist to "mgm-config.json"...')

        # Copy static pairlist to mgm-config.json as pair whitelist
        with open(f'{self._basedir}/user_data/mgm_pair_lists/Binance-USDT-Top-Volume-StaticPairList.json', ) \
                as static_pairlist:
            mgm_config_json = json.load(static_pairlist)

        with open(f'{self._basedir}/user_data/mgm-config.json', ) as mgm_config:
            mgm_config_data = json.load(mgm_config)

        mgm_config_data['exchange']['pair_whitelist'] = mgm_config_json['exchange']['pair_whitelist']

        with open(f'{self._basedir}/user_data/mgm-config.json', 'w') as target_f:
            json.dump(mgm_config_data, target_f, indent=4)

        # self._logger.error('🤷 Something happened on the way to heaven 🌟🤦')

    def hyperopt(self, timerange: str = None, strategy: str = None, spaces: str = None, enable_protections: bool = True,
                 random_state: int = None, apply_best_results: bool = True, clean_start: bool = False,
                 save_output: bool = True, output_path: str = None, output_file_name: str = None):
        """
        HyperOpt Magic. Runs HyperOpt process to find out the most positive settings.

        :param timerange: (str, Optional): timerange from/to in format (start-end): yyyymmdd-yyyymmdd
            or preset [up, down, side]. Defaults to value in '.hurry'
        :param strategy: (str, Optional): Hyper Opt strategy to use. Defaults to value in '.hurry'
        :param spaces: (str, Optional): Spaces (space delimited) to optimize
            for [default, all, buy, sell, roi, stoploss, etc]. Defaults to value in '.hurry'
        :param enable_protections: (bool, Optional): Add '--enable-protections' flag to HO-command. Defaults to True.
        :param random_state: (int, Optional): Add '--random-state random_state' flag to HO-command. Defaults to None.
        :param apply_best_results: (bool, Optional): Apply 'best' HO results direct after HO? Defaults to True.
        :param clean_start: (bool, Optional): Cleanup MoniGoMani before starting the HO? Defaults to False.
        :param save_output: (bool, Optional) Save the output to a '.log' file. Defaults to True
        :param output_path: (str) Path to the output of the '.log' file.
            Defaults to 'Some Test Results/MoniGoMani_version_number/'
        :param output_file_name: (str, Optional) Name of the '.log' file.
            Defaults to 'HyperOptResults-<Current-DateTime>.log'
        """

        if clean_start is True:
            self.cleanup()

        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Starting HyperOpt run. Keep calm while your computer burns 🔥')
        self._logger.info('💨 💨 💨')

        timerange = self.__get_preset_timerange(timerange)

        if strategy is None:
            strategy = self.monigomani_config.config['hyperopt']['strategy']

        if spaces is None:
            spaces = self.monigomani_config.config['hyperopt']['spaces']

        cmd = '$ft_binary hyperopt -s $ho_strategy \
              -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json \
              --hyperopt-loss $ho_loss --spaces $ho_spaces -e $ho_epochs --timerange $timerange '

        if enable_protections is True:
            cmd = f'{cmd.strip()} --enable-protections'

        if random_state is not None:
            cmd = f'{cmd.strip()} --random-state $random_state'

        cmd = Template(cmd).substitute(
            ft_binary=self.monigomani_config.config['ft_binary'],
            ho_strategy=strategy,
            ho_loss=self.monigomani_config.config['hyperopt']['loss'],
            ho_spaces=spaces,
            ho_epochs=self.monigomani_config.config['hyperopt']['epochs'],
            timerange=timerange,
            random_state=random_state)

        if output_file_name is None:
            output_file_name = f'HyperOptResults-{datetime.now().strftime("%d-%m-%Y-%H-%M-%S")}.log'
        self.monigomani_cli._exec_cmd(cmd, save_output, output_path, output_file_name)

        if (apply_best_results is True) and (strategy == 'MoniGoManiHyperStrategy'):
            self.monigomani_cli._exec_cmd('mv ./user_data/strategies/MoniGoManiHyperStrategy.json '
                                          './user_data/mgm-config-hyperopt.json')
        else:
            self.monigomani_cli._exec_cmd(f'rm ./user_data/strategies/{strategy}.json')

        self._logger.info('🍺 HyperOpt run ready... 🥵')

    def hyperopt_show_results(self, only_best: bool = True, only_profitable: bool = False):
        """
        Show hyperopt results after choosing a .fthypt file.

        :param only_best: (bool, Optional); Show only best epochs. Defaults to True.
        :param only_profitable: (bool, Optional); Show only profitable epochs. Defaults to False.
        """

        fthypts = map(os.path.basename, sorted(glob.glob(f'{self._basedir}/user_data/hyperopt_results/*.fthypt'),
                                               key=os.path.getmtime, reverse=True))

        dat = list(fthypts)

        if len(dat) == 0:
            self._logger.warning('Whoops, no hyperopt results could be found.')
            sys.exit(1)

        questions = [
            {
                'type': 'list',
                'name': 'fthypt_file',
                'message': 'Please select the hyperopt results you want to show: ',
                'choices': dat
            },
        ]

        answers = prompt(questions=questions)

        choice = answers.get('fthypt_file')

        self._logger.info(f'👉 Showing hyperopt results for: {choice}')

        best = '--best' if only_best is True else ''
        profit = '--profitable' if only_profitable is True else ''

        dcd = f'{self.monigomani_config.config["ft_binary"]} hyperopt-list --hyperopt-filename "{choice}" {best} {profit}'
        self._logger.debug(dcd)

        self.monigomani_cli._exec_cmd(dcd)

    def hyperopt_show_epoch(self, epoch: int = 0):
        """
        Shows the HyperOpt results for given epoch.

        :param epoch: (int) The epoch number to show the results from.
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Hyperopt show results')
        self._logger.info('💨 💨 💨')

        if epoch == 0:
            self._logger.error('🤷 Please pass the epoch number through. Hint: mgm-hurry hyperopt_show_epoch --epoch=837')
            sys.exit(1)

        self._logger.info('👉 Showing HyperOpt results for epoch # {epoch}')

        self.monigomani_cli._exec_cmd(f'{self.monigomani_config.config["ft_binary"]} hyperopt-show -n {epoch}')

    def hyperopt_apply_epoch(self, epoch: int = 0, run: int = 1):
        """
        Apply HyperOpt results from given epoch

        :param epoch: (int): The epoch number to apply the results from.
        :param run: (int, Optional): Defaults to 1. Run number of hyperopt. First run has different command than second.
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Hyperopt apply epoch')
        self._logger.info('💨 💨 💨')

        if epoch == 0:
            self._logger.error('🤷 Please pass the epoch number through. Hint: mgm-hurry hyperopt_apply_epoch --epoch=837')
            sys.exit(1)

        self._logger.info(f'👉 Applying HyperOpt results of epoch # {epoch}')

        # View & Apply HyperOpt Results from a trusted <epoch of choice>:
        self.monigomani_cli._exec_cmd(
            (f'{self.monigomani_config.config["ft_binary"]} hyperopt-show -n {epoch} -c ./user_data/mgm-config.json \
             -c ./user_data/mgm-config-private.json  && \
             mv ./user_data/strategies/MoniGoManiHyperStrategy.json ./user_data/mgm-config-hyperopt.json'                                                                                                         )
        )

        self._logger.info(f'🍺 Hyperopt results of epoch # {epoch} are applied.')

    def backtest(self, timerange: str = None, enable_protections: bool = True):
        """
        Run a backtest session.

        :param timerange: (string, Optional): The target timerange for backtesting. Defaults to None.
        :param enable_protections: (bool, Optional): Whether or not to enable protections. Defaults to True.
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Start backtesting. Lets see how it all turns out!')
        self._logger.info('💨 💨 💨')

        timerange = self.__get_preset_timerange(timerange)

        cmd = ('$ft_binary backtesting -s $ho_strategy -c ./user_data/mgm-config.json \
               -c ./user_data/mgm-config-private.json --timerange $timerange'                                                                             )

        if enable_protections is True:
            cmd = f'{cmd} --enable-protections'

        cmd = Template(cmd).substitute(
            ft_binary=self.monigomani_config.config['ft_binary'],
            ho_strategy=self.monigomani_config.config['hyperopt']['strategy'],
            timerange=timerange)

        self.monigomani_cli._exec_cmd(cmd)

        self._logger.info('🍺 Backtesting ready... 🤑')

    def start_trader(self, dry_run: bool = False):
        """
        Start the trader. Your ultimate goal!

        :param dry_run: (bool, Optional): Use dry_run mode. Defaults to False
        """
        self._logger.info('💨 💨 💨')
        self._logger.info('👉 Start trader')
        self._logger.info('💨 💨 💨')

        cmd = (
            f'{self.monigomani_config.config["ft_binary"]} trade -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json \
            -c ./user_data/mgm-config-hyperopt.json --strategy {self.monigomani_config.config["hyperopt"]["strategy"]}'
        )

        if dry_run is True:
            cmd = f'{cmd} --dry-run'

        self.monigomani_cli._exec_cmd(cmd)

    def __setup_telegram(self) -> bool:
        """
        Questionnaire to setup Telegram Bot

        :return bool: False if no answers are given, True if all went ok.
        """
        questions = [
            {
                'type': 'confirm',
                'message': 'Do you want to also setup your Telegram bot? ',
                'name': 'proceed_telegram',
                'default': True,
            },
            {
                'type': 'confirm',
                'message': 'Do you want to enable the Telegram Bot?',
                'name': 'enable_telegram',
                'default': True,
                'when': lambda result: result['proceed_telegram']
            },
            {
                'type': 'password',
                'name': 'telegram_token',
                'message': 'Please enter your Telegram Bot token: ',
                'default': '',
                'when': lambda result: result['proceed_telegram'] and result['enable_telegram']
            },
            {
                'type': 'input',
                'name': 'telegram_chat_id',
                'message': 'Please enter the chat ID: ',
                'default': '',
                'when': lambda result: result['proceed_telegram'] and result['enable_telegram']
            },
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            return False

        if answers.get('proceed_telegram') is True:
            opt = {
                'enable_telegram': answers.get('enable_telegram'),
                'telegram_token': answers.get('telegram_token'),
                'telegram_chat_id': answers.get('telegram_chat_id')
            }

            self._save_telegram_credentials(opt)

        return True

    def _save_exchange_credentials(self, cred: dict):
        """
        Save exchange credentials to "mgm-config-private.json"

        :param cred: (dict) - List containing values for [exchange,api_key,api_secret]
        """
        if len(cred) == 0:
            self._logger.warning(
                'Did not write exchange credentials to "mgm-config-private.json" because no data was passed.')
            return False

        try:
            with open(self._basedir + '/user_data/mgm-config-private.json', 'a+') as file:
                data = json.load(file)
        except:
            data = {}

        data['exchange'] = {
            'name': cred['exchange'],
            'key': cred['api_key'],
            'secret': cred['api_secret']
        }

        with open(f'{self._basedir}/user_data/mgm-config-private.json', 'w+') as outfile:
            json.dump(data, outfile, indent=4)

        self._logger.info('🍺 Exchange settings written to "mgm-config-private.json"')

    def _save_telegram_credentials(self, opt: dict):
        """
        Save Telegram bot settings

        :param opt: (dict): list containing values for [enable_telegram,telegram_token,telegram_chat_id]
        """
        if len(opt) == 0:
            self._logger.warning(
                'Did not write telegram credentials to "mgm-config-private.json" because no data was passed.')
            return False

        with open(f'{self._basedir}/user_data/mgm-config-private.json', ) as file:
            data = json.load(file)

        data['telegram'] = {
            'enabled': opt['enable_telegram'],
            'token': opt['telegram_token'],
            'chat_id': opt['telegram_chat_id']
        }

        with open(f'{self._basedir}/user_data/mgm-config-private.json', 'w+') as outfile:
            json.dump(data, outfile, indent=4)

        self._logger.info('🍺 Telegram bot settings written to "mgm-config-private.json"')

    def __get_preset_timerange(self, timerange: str) -> str:
        """
        Parses given timerange-string into according timerange dates

        :param timerange: (str) The timerange-string to parse [up, down, side]
        :return str: The parsed timerange string in yyyymmdd-yyyymmdd format
        """

        tr_input = timerange

        if timerange is None:
            timerange = self.monigomani_config.config['timerange']
        if timerange == 'down':
            timerange = '20210509-20210524'
        if timerange == 'side':
            timerange = '20210518-20210610'
        if timerange == 'up':
            timerange = '20210127-20210221'

        tr_output = timerange

        self._logger.info(f'☀️ Timerange string parsed from "{tr_input}" to "{tr_output}"')

        return timerange

    @staticmethod
    def filter_line(line: str) -> bool:
        """
        Checks if line needs to be filtered out.

        :param line: Line to check if it needs to be filtered out
        :return bool: True if line needs to be filtered out. False if it's allowed to be printed out
        """

        ignored_lines = {
            'INFO - Verbosity set to',
            'INFO - Using user-data directory:',
            'INFO - Using data directory:',
            'INFO - Parameter -j/--job-workers detected:',
            'INFO - Parameter --random-state detected:',
            'INFO - Checking exchange...',
            'INFO - Exchange "',
            'INFO - Using pairlist from configuration.',
            'INFO - Validating configuration ...',
            'INFO - Starting freqtrade in',
            'INFO - Lock',
            'INFO - Instance is running with',
            'INFO - Using CCXT',
            'INFO - Applying additional ccxt config:',
            'INFO - Using Exchange',
            'INFO - Using resolved exchange',
            'INFO - Found no parameter file.',
            'INFO - Strategy using order_types:',
            'INFO - Strategy using order_time_in_force:',
            'INFO - Strategy using stake_currency:',
            'INFO - Strategy using stake_amount:',
            'INFO - Strategy using protections:',
            'INFO - Strategy using unfilledtimeout:',
            'INFO - Strategy using use_sell_signal:',
            'INFO - Strategy using sell_profit_only:',
            'INFO - Strategy using ignore_roi_if_buy_signal:',
            'INFO - Strategy using sell_profit_offset:',
            'INFO - Strategy using disable_dataframe_checks:',
            'INFO - Using resolved pairlist StaticPairList from',
            'INFO - Using resolved hyperoptloss',
            'INFO - Removing `',
            'INFO - Using indicator startup period:',
            'INFO - Note: NumExpr detected',
            'INFO - NumExpr defaulting to',
            'INFO - Dataload complete. Calculating indicators',
            'INFO - Found',
            'INFO - Number of parallel jobs set as:',
            'INFO - Effective number of parallel workers used:'
        }

        matches = '\n'.join(ignored_line for ignored_line in ignored_lines if ignored_line.lower() in line.lower())
        if len(matches) > 0:
            return True

        return False

    def __read_config(self):
        """
        Reads config values out of ".hurry" config file.

        :return config (dict) Dictionary containing all config key/value pairs. Or returns None.
        """
        with open('.hurry', 'r') as yml_file:
            config = yaml.full_load(yml_file) or {}

        if 'config' in config:
            return config['config']

        # Something happened on the way to heaven. Let's fix it to create a default ".hurry" config file
        self.__write_config()
        return None

    def __write_config(self, config: dict = None):
        """
        Write config-array to ".hurry" config file.
        Writes the passed config dictionary or if nothing passed, it will write default values.

        :param config: (dict, Optional) The config values to store. Defaults to None.
        """
        if config is None:
            config = {
                'config': {
                    'install_type': 'docker',
                    'timerange': '20210501-20210616',
                    'exchange': 'binance',
                    'hyperopt': {
                        'strategy': 'MoniGoManiHyperStrategy',
                        'loss': 'WinRatioAndProfitRatioLoss',
                        'spaces': 'buy sell',
                        'quote': 'USDT',
                        'epochs': 1000
                    }
                }
            }

        with open('.hurry', 'w+') as file:
            yaml.dump(config, file)

        self.monigomani_config.reload()

        self._logger.info('🍺 Configuration data written to ".hurry" file')


if __name__ == '__main__':
    try:
        fire.Fire(MGMHurry)
    except KeyboardInterrupt:
        print('😼 KTHXBAI')
        sys.exit(0)
